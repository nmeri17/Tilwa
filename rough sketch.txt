flesh out auth controller actions. Implement loginAs

install transphpform and turbo

->createQueryBuilder()

->select('u')->from(User::class, 'u')

->where('u.email = ?1')->setParameter(1, $reqData['email']) // this should go in "good to know"

route caching
	- all the routes should pass through regexForm and get saved with the result under a trie the way they were defined. The aim is to skip this replacement phase during runtime
	- only needed if you're using a lot of dynamic routes

try to deploy on azure

When you find a way of identifying orm models, revisit NoSqlLogic->setup

when cacheManager is integrated:
	- refactor its usage wherever it appears in respect to accessing nested objects; tags etc
	- is the override pattern we're using good or can it be updated while in the cache?

#
work needed on updateReactor

what container is used to hydrate handler method on the queued job?

on flow hit, upload the rest into the shared space for all users insted of simply discarding it

#
look into uses of [needsArguments]


##controllers and services
type-hint alter classes. we expect them to have a typeHintFactory implementation that returns a closure that when called, yields a builder

<?php
function jj (NewsRequest $request, NewsRepository $news) {

	/*new way*/
	$newData = $this->newsService->mergeValues($request, $news->get()); // conceals News::where(id, id) stored on property x of [newsRepository]. calling methods on this triggers the internal closure that releases a builder
	$news->update($newData); // cleaner. gets are lazier and under developer's control. avoids duplicating builders
}
/* after hydration, [typeHintFactory] is called with this id, and passed down */

Bar:
	- app level service entry into repositories
	- controllers from app level services
Meaning they probably need an external factory that boots them the same way executable controllers are booted

Wrap all post commands in transactions