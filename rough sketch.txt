flesh out auth controller actions. Implement loginAs

install plates

->createQueryBuilder()

->select('u')->from(User::class, 'u')

->where('u.email = ?1')->setParameter(1, $reqData['email'])

route caching
	- all the routes should pass through regexForm and get saved with the result under a trie the way they were defined. The aim is to skip this replacement phase during runtime
	- only needed if you're using a lot of dynamic routes

try to deploy on azure

When you find a way of identifying orm models, revisit NoSqlLogic->setup
	
	- After route is found, we want to (pull the stored flow state from cache and hydrate). "Hydration" translates to the actual functionality behind those methods (3)

	- write flow route matching pattern (4)

	- Each write to the database triggers either redis subscriptions or tilwa event listeners. the handler uses the prepared statement to look up matching items/tags in the cache and refreshes them (5)

	- what happens when they're accessed? (6)
		- delete items under this tag(s). expire the caches in 20 mins but delete each route pattern after it's accessed
#
update an App property each time a call is made to retrieve user. If this indicator property is empty, another user could use this response, so store for longer (or make more accessible to more than current user). This saves us from making those caches for each user
#
Flows have a `hydrate` method that can create instantiate a flow from an incoming request. Useful for 3rd party consumers of the api
#work needed on FlowFinder

https://laravel.com/docs/8.x/queues#running-the-queue-worker
php artisan queue:work